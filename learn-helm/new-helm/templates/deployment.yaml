
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Values.component_name }}
  labels:
    app: {{ .Values.component_name }}
spec:
  replicas: 2
  securityContext:
    runAsNonRoot: true
    runAsUser: 101
    runAsGroup: 101
    fsGroup: 101
  selector:
    matchLabels:
      app: {{ .Values.component_name }}
  strategy:
    rollingUpdate: { maxSurge: 1, maxUnavailable: 0 }
    type: RollingUpdate

  template:
    metadata:
      labels: { app: {{ .Values.component_name }} }
    spec:
      serviceAccountName: {{ .Values.component_name }}

      # Pod lifecycle + graceful shutdown
      terminationGracePeriodSeconds: 30
      containers:
        - name: {{ .Values.component_name }}
          image: {{ .Values.image.repository }}/{{ .Values.component_name }}:{{ default "latest" .Values.image.tag }}
          imagePullPolicy: Always

          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false
            seccompProfile: { type: RuntimeDefault }
            capabilities: { drop: [ "ALL" ] }

          volumeMounts:
            - name: tmp
              mountPath: /tmp

          ports:
            - containerPort: 8080

  {{- if .Values.env }}
          env:
  {{ toYaml .Values.env | nindent 12 }}
    {{- end}}
          # bring in non-secret app config (keep this if you still use the ConfigMap)
          envFrom:
            - configMapRef:
                name: {{ .Values.component_name }}
            {{- if eq (.Values.component_name) "catalogue" }}
            {{- with .Values.envFrom }}
            {{- toYaml . | nindent 12 }}
            {{- end }}

            {{- end }}



          resources:
            requests: { cpu: {{ .Values.resources.requests.cpu }} , memory: {{ .Values.resources.requests.memory }} }
            limits:   { cpu: {{ .Values.resources.limits.cpu }} , memory: {{ .Values.resources.limits.memory }} }


          readinessProbe:
              httpGet: { path: "/health", port: {{ .Values.appPort }} }
              initialDelaySeconds: 5
              periodSeconds: 10
              timeoutSeconds: 2
              failureThreshold: 3
          livenessProbe:
              httpGet: { path: "/health", port: {{ .Values.appPort }} }
              initialDelaySeconds: 15
              periodSeconds: 10
              timeoutSeconds: 2
              failureThreshold: 3
          startupProbe:
            httpGet: { path: /health, port: 8080 }
            periodSeconds: 2
            failureThreshold: 30


          lifecycle:
            preStop:
              exec: { command: ["/bin/sh","-c","sleep 5"] }

      # Scheduling rules
      affinity:
        # Keep replicas on different NODES
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - topologyKey: kubernetes.io/hostname
              labelSelector:
                matchLabels: { app: {{ .Values.component_name }} }

      # Spread evenly across AZs
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: ScheduleAnyway
          labelSelector:
            matchLabels: { app: {{ .Values.component_name }} }

      # Scratch space
      volumes:
        - name: tmp
          emptyDir:
            sizeLimit: 64Mi
  {{- if eq (.Values.component_name) "frontend" }}
      {{- with .Values.extraVolumes }}
      {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.extraVolumeMounts }}
      {{- toYaml . | nindent 8 }}
      {{- end }}
  {{- end }}
      volumeMounts:
  {{ - if eq (.Values.component_name) "frontend" }}
      {{- with .Values.extraVolumeMounts }}
      {{- toYaml . | nindent 8 }}
      {{- end }}
  {{- end }}